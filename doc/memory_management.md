内存管理设计
====

使用bitmap比较简单,但是不符合PT_OS的想法,我希望实现一个比较使用原型. 我希望采用linux或者
其他系统的机制,然后进行简化版的实现.  我会实现三个版本的内存管理机制，分别为
1) bitmap + 页面池
2) buddy + vma
3) buddy + vma + slab

内存映射图
----

这是简单的内映射,对于下面的管理部分会有帮助. PT_OS 使用的物理内存的最大数量为128MB.
其中前4M/32MB为内核使用的部分,之后的内存由用户程序使用.

**0-1MB:** 启动部分, 其内容如下物理地址顺序给出

	mbr:    0x7c00
	loader: 0x7e00
	vga:    0xb800
	BIOS:   固定多段地址

**1-2MB:** 内存管理数据,进程管理数据

	mm_v1方式：位示图的方式管理page
		页目录: 1MB ~ 1MB+4K
		页表:   1MB+4K ~ 1MB+4K+4K*32 = 1MB+132KB
		位示图1: 1MB + 132KB ~ 1MB + 136KB	使用4K的位示图来管理128MB的物理/内核内存，内核和物理地址一一对应(和Linux反过来，从0开始)。
		虽然Linux的设计对编译程序虚拟地址时有好处，但是看得我廷烦，所以就不用了。
		进程位示图#: 在进程创建时进行维护，在进程自己的空间内存

		内核可以使用 虚拟地址的0-32M 物理地址的0-128M
		进程的虚拟内存空间为32M-128M 物理地址空间0-128M
		进程在切换时使用相同虚拟地址映射的内存需要进行"swap in/off"


	mm_v2方式：
		页目录:	1MB ~ 1MB+4K
		页表:	1MB+4K ~ 1MB+4K+4K*32 = 1MB+132KB
		buddy结构:	1MB+132KB ~ 1MB+132KB+4KB = 1MB+136K
		page结构:	1MB+512KB ~ 2MB

**2-3MB:** 内核程序

	build/ 目录下的kernel.elf被映射到该位置

**3-4MB:** 进程管理结构

	task结构


**4MB-8MB:** 文件系统及其buffer

	一些管理结构和变量的位置：
		channel_cnt: 4MB
		ide_channel： 4MB + 1B


		8MB-4KB ~ 8MB 为buffer


**8MB-128MB:** 随意使用部分


1)物理页面管理
----

我使用了linux中的伙伴机制对物理页面进行管理


2)细粒度内存管理
----

该部分设计用来解决小块内存的分配, 小块内存是小于4KB的.
