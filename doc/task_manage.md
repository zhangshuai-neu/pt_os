任务管理
====

只实现内核线程和用户进程，没有用户线程的设计
用户进程和内核线程的区别：有没有独立的存储空间

任务存储
----

    任务的存储空间为物理内存的3M~4M之间

    内核thread：
    内核task结构（struct task 和 kernel stack）
    一共4K

    用户进程：
    struct task 和 kernel stack,再包括一个虚拟地址空间管理的bitmap(4K)
    一共8K


    任务以如下单位在内核进行存储，每个存储单位占据8K存储空间。
    虽然内核线程占据的空间比较小，但是仍然按照最大的范围预留。

    //======= 存储单位 =====
    / 0 task struct
    /
    /    ^
    /    |
    / 4K kstack
    / 4K bitmap 任务的虚拟地址空间
    /    |
    /    V
    / 8K
    //=====================

    最大占用空间 = 8K * 128 = 1M

    我规定最大任务数量为128个，其中，由于程序从loader.s进入kernel/main.c运行，
    这也被我规定为一个内核线程。但是由于该线程的结构和栈的存储与其他任务不同，是
    独立出来的，因此我将第一个task的存储单元空余出来,即 3M~3M+8k之间是空白的。

    3M~3M+8k之间的空白空间，我用来存放任务调度需要的一些数据结构。

任务调度
----

#### 调度方法

**1) 轮询调度:**  

    优先级：
    任务的优先级只决定的任务的执行时间，与调度的选择无关。
    优先级从 1～100

    任务执行时间：
    优先级*N为任务的执行时间(N为固定数量的调度周期)

    任务的调度选择：
    按照ready队列的FIFO的顺序进行调度

    任务队列：
    由于list_node已经被实现到了task结构中，并不需要另外的数据结构。

**2) 类cfs调度:**

    优先级：
    任务的优先级只决定的任务的执行时间，与调度的选择无关。
    优先级从 1～100

    任务的执行时间：执行时间分成两部分
    虚拟执行时间 virt_tick
    实际执行时间 real_tick
    任务的优先级不同，优先级*N为任务的real_tick(N为固定数量的调度周期)

    任务的调度选择：
    总是选择virt_tick最小的任务进行调度。
    保证各个任务在宏观上是均匀推进的。

    任务队列：
        任务的ready队列，按照virt_tick的从小到大的顺序进行执行。

    一些问题：
        a) virt_tick和real_tick的越界问题。
        b) 调度器带来的罚值，调度器执行的时间可能会被计算到任务的实际执行时间中
        c) 新任务的过度补偿问题（新任务的virt_tick不能为0）

**3) 实时调度**

    固定优先级的抢占式调度
