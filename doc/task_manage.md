任务管理
====

只实现内核线程和用户进程，没有用户线程的设计
用户进程和内核线程的区别：有没有独立的存储空间

任务存储
----

    任务的存储空间为物理内存的3M~4M之间

    内核thread：
	内核task结构（struct task 和 kernel stack）
    一共4K

    用户进程：
    struct task 和 kernel stack,再包括一个虚拟地址空间管理的bitmap(4K)
    一共8K


    任务以如下单位在内核进行存储，每个存储单位占据8K存储空间。
    虽然内核线程占据的空间比较小，但是仍然按照最大的范围预留。

    //======= 存储单位 =====
    0 task struct

        ^
        |
    4K kstack
    4K bitmap 任务的虚拟地址空间
        |
        V
    8K
    //=====================

    最大占用空间 = 8K * 128 = 1M

    我规定最大任务数量为128个，其中，由于程序从loader.s进入kernel/main.c运行，
    这也被我规定为一个内核线程。但是由于该线程的结构和栈的存储与其他任务不同，是
    独立出来的，因此我将第一个task的存储单元空余出来,即 3M~3M+8k之间是空白的。

    3M~3M+8k之间的空白空间，我用来存放任务调度需要的一些数据结构。

任务调度
----

#### 调度方法

**1) 轮询调度:**  

    所有任务的优先级相同，循环调度
    所有优先级都为1，运行时间为1*N (N为固定real_tick数)
    由于list_node已经被实现到了task结构中，并不需要另外的数据结构。

**2) 类cfs调度: **

    任务的优先级不同，按照 virt_tick进行调度(最小的先执行)
    虚拟执行时间 virt_tick
    实际执行时间 real_tick
    优先级从 1～10，每个优先级的实际运行的单位时间为 (优先级*N，N为固定real_tick数)

    一些问题：
        a) virt_tick和real_tick的越界问题。
        b) 调度器带来的罚值，调度器执行的时间可能会被计算到任务的实际执行时间中

**3) 实时调度**

    固定优先级的抢占式调度
